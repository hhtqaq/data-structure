## 平衡二叉树
### 1 介绍
&emsp;&emsp;二叉排序树查找算法的性能取决于二叉树的结构，而二叉排序树的形状则取决于其数据集。
如果数据呈有序排列，则二叉排序树是线性的，查找的时间复杂度为O(n);反之，如果二叉排序树的结构
合理，则查找速度较快，查找的时间复杂度为O(logn)。事实上，树的高度越小，查找的速度越快。因此
，希望二叉树的高度尽可能小。本节将讨论一种特殊的二叉排序树，称为为平衡二叉树（Balanced Binary 
Tree），因由前苏联数学家Adelson-Velskii和Landis提出，所以又称为AVL树。

#### 1.1 二叉排序树的定义
&emsp;&emsp;二叉排序树是一颗空树，或者是具有下列性质的二叉排序树。

1）左子树和右子树的深度之差绝对值不超过1。

2）左子树和右子树也是平衡二叉树。

&emsp;&emsp;若将二叉树上节点的**平衡因子**定义为该节点的左右子树的深度之差，则平衡二叉树上所有
结点的平衡因子只可能是-1、0和1。所以只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉
树就是不平衡的。

&emsp;&emsp;因为AVL树上人和结点的左右子树的深度之差都不差过1，则可以证明他的时间复杂度为logn。

#### 1.2 平衡二叉树的平衡调整方法
&emsp;&emsp;如何创建一颗平衡二叉树呢？插入结点时，首先按照二叉排序树处理，若插入结点后破坏了
平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到里插入节点最近且平衡因子绝对值超过
1的祖先结点，以该节点为根的字数称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。

&emsp;&emsp;一般情况下，假设最小不平衡子树的根结点为A，则失去平衡后进行调整的规律课归纳为下列4
种情况。

 - (1)LL型(插入发生在左子树的左结点)：右旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/ll.png)
 - (2)RR型(插入发生在右子树的右结点)：左旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/rr.png)
 - (3)LR型(插入发生在左子树的右结点)：先左旋变成LL型，再右旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/lr.png)
 - (4)RL型(插入发生在右子树的左结点)：先右旋变成RR型，再左旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/rl.png)
  
**理解：**  
 - 左旋中的“左”，意味着“被旋转的节点将变成一个左节点”
 
 - 右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。
  
#### 1.3 平衡二叉树的插入

   - 【算法思想】
   
     1.二叉排序树的插入
    
     2.插入后高度修改为左右最大子树高度+1
     
     3.判断左右子树高度差是否小于2，判断结点是否失衡
     
     4.当前结点node失衡：
     
     插入发生在左子树的左结点，单右旋rightRotate(node)
      
     插入发生在左子树的右结点，先左旋node.left=leftRotate(node.left) 再rightRotate(node)
    
     插入发生在右子树的右结点，单左旋leftRotate(node)
    
     插入发生在右子树的左结点，先右旋node.right=rightRotate(node.right) 再leftRotate(node)

#### 1.4 平衡二叉树的缺点

&emsp;&emsp;1 为了保证高度平衡，动态插入和删除的代价也随之增加。**红黑树**这种更加高效的查找结构可以解决这个问题。

&emsp;&emsp;2 在大数据量查找环境下（比如说系统磁盘里的文件目录，数据库中的记录查询 等），所有的二叉查找树结构
（BST、AVL、RBT）都不合适。如此大规模的数据量，全部组织成平衡二叉树放在内存中是不可能做到的。那么
把这棵树放在磁盘中吧。问题就来了：假如构造的平衡二叉树深度有1W层。那么从根节点出发到叶子节点很可能
就需要1W次的硬盘IO读写。所有二叉查找树结构的查找代价都与树高是紧密相关的，能否通过减少树高来进一步
降低查找代价呢。我们可以通过多路查找树的结构来做到这一点。

&emsp;&emsp;3 每个节点要额外保存一个平衡值，或者说是高度差height,更耗内存。

### 2 平衡二叉树的时间复杂度
#### 2.1 查找
&emsp;&emsp;没什么要说的，因为严格平衡，即使是查找叶子结点最坏时间复杂度也为O(logn)。
#### 2.2 插入
&emsp;&emsp;首先插入需要找到插入位置，时间复杂度即为查找的时间O(logn),即使为了平衡需要旋转，最多只
有两次。所以，时间复杂度任然为O(logn)。
#### 2.3 删除
&emsp;&emsp;同插入，为了找到待删除结点，需要查找，时间复杂度T1=O(logn)。另外删除之后必须检查从删除
结点开始到根节点路径上的所有结点的平衡因子。每一次删除操作最多需要O(logn)次旋转，时间复杂度T2=O(logn)
。所以删除操作的时间复杂度为T1+T2=O(2logn).


### 3 平衡二叉树的应用场景 
  
&emsp;&emsp;1 AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，
故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，
只是对查找特别有要求，AVL还是优于红黑的。



**说明：**

&emsp;&emsp;完全二叉树，二叉查找树，平衡二叉树都是从**内存**中查找数据，相对顺序存储、链表来说
能够提升查找效率，但如果是海量数据，无法一次性读到内存中时，这些数据结构就不在适用。
此时就需要研究从**磁盘**中查找海量数据的方法，就引入了b树和b+树