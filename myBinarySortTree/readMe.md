##二叉排序树
### 1.1 介绍
&emsp;&emsp;二叉排序树（Binary Sort Tree） 又称为二叉查找树（Binary Search Tree），它是一种对排序和查找都很有用的特殊二叉树。

#### 1.1.1 二叉排序树的定义
&emsp;&emsp;二叉排序树是一颗空树，或者是具有下列性质的二叉树。

1）若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值。

2）若它的右子树不为空，则右子树上所有节点的值大于它的根节点的值。

3）它的左右子树也都是二叉排序树。

&emsp;&emsp;二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质：中序遍历
一颗二叉树可以的到一个结点值递增的有序序列。

#### 1.1.2 二叉排序树的创建
&emsp;&emsp;一般地：都是给一个数组，将数组转化成一个二叉排序树。


#### 1.1.3 二叉排序树的查找
&emsp;&emsp;因为二叉排序树可以看成是一个有序表，所以在二叉排序树上进行查找和折半查找类似，
也是一个逐步缩小查找范围的过程。

 - 算法 二叉排序树的递归查找
 
    【算法思想】
    
    1）若二叉排序树为空，则查找失败返回空指针。
      
    2）若二叉排序树非空，将给定值key与根节点关键字data.key进行比较：
    
    ①若key=data.key，则查找成功，返回根节点地址。
    
    ②若key>data.key，则进一步查找右子树。
    
    ③若key<data.key，则进一步查找左子树。
    
&emsp;&emsp;从二叉排序树查找其关键字等于给定值的节点过程，恰是走了一条从根节点到该节点的路径的过程。
路程等于节点所在的层次数。所以二叉排序树的查找时间复杂度是和树的结构相关的，对于一个已经
有序的序列，使用二叉排序树这种结构存储，那么他的树结构就会趋于链式。**(所以序列越乱越好)**这里假设数的深度为n,
这样他的平均查找长度为（n+1）/2(和数组和单链表这种顺序查找相同)，当然这是最差的情况。
（后面为了避免出现这种情况，推出了二叉平衡树）

&emsp;&emsp;最好的情况下是，二叉排序树的形态和折半查找的判定树相似。时间复杂度是logn。

![Image text](https://github.com/hhtqaq/data-structure/raw/master/myBinarySortTree/img-file/differentBST.png)

&emsp;&emsp;可见二叉排序树的查找和折半查找相差不大，整体而言会略低一点。但就维护表的有序性
而言，二叉排序树更加有效，因为无需移动记录，只需要修改指针即可完成对节点的插入和删除操作。
因此，对于需要经常进行插入，删除和查找运算的表，采用二叉排序树比较好。


#### 1.1.4 二叉排序树的插入
&emsp;&emsp;二叉排序树的插入操作是以查找为基础的。要将一个关键字值为key的节点S插入到二叉排序树中，
则需要从根节点开始寻找，插入一个空的节点。

- 【算法思想】
    
   1）若二叉排序树为空，则将待插入的节点作为根结点。
   
   2）若二叉排序树不为空，则用根节点的值与key比较大小 
   
    ①若key>data.key，则进一步插入右子树。
  
    ②若key<data.key，则进一步插入左子树。


#### 1.1.5 二叉排序树的删除
&emsp;&emsp; 被删除的节点可能是二叉排序树中的任意一个结点，删除节点后，要根据其位置不同修改其双
亲结点以及相关节点的引用（指向），以保持二叉排序树的特性。
    - 【算法思想】
    1）如果待删除结点为叶子结点，那么只要修改其双亲节点的引用为null即可。
    2）如果待删除结点只有左子树，或者只有右子树。
    ①假设只有右子树，且待删除结点为左孩子，那么只要将其双亲节点的左孩子结点指向其自身的右孩子
    结点。
    ②假设只有右子树，且待删除结点为右孩子，那么只要将其双亲节点的右孩子结点指向其自身的右孩子
     结点。
    ③假设只有左子树，且待删除结点为左孩子，那么只要将其双亲节点的左孩子结点指向其自身的左孩子
    结点。
    ④假设只有左子树，且待删除结点为右孩子，那么只要将其双亲节点的右孩子结点指向其自身的左孩子
        结点。
    3）如果待删除结点左子树和右子树都不为空，
    ①如果待删除结点的左子树的右子树结点不为null，那么找到左子树的最右结点，将待删除结点的值，改为最右节点的值，将最右节点置为null。
    ②如果待删除结点的左子树的右子树节点为null,那么将待删除结点的右孩子结点指向待删除结点的左孩子结点的右孩子结点，再讲该节点指向它双亲。
     
     
#### 1.1.6 总结：
二叉排序树的查找时间复杂度是和树的形态相关的，对于一个已经有序的序列，那么他的树形态就会趋于链式，和链表的查找时间相同。
为了避免这种情况出现，研究出了AVL树，也叫平衡二叉树。
    
    
**说明：**

&emsp;&emsp;完全二叉树，二叉查找树，平衡二叉树都是从**内存**中查找数据，相对顺序存储、链表来说
能够提升查找效率，但如果是海量数据，无法一次性读到内存中时，这些数据结构就不在适用。
此时就需要研究从**磁盘**中查找海量数据的方法，就引入了b树和b+树