##红黑树
### 1 介绍
&emsp;&emsp;为了减少平衡二叉树为了保证高度平衡花费的动态插入和删除的代价，产生的自
平衡红黑树，是一种高效的查找树。它是由 Rudolf Bayer于1978年发明，在当时被称为对称
二叉 B 树(symmetric binary B-trees)。后来，在1978年被Leo J. Guibas 和 Robert Sedgewick 
修改为如今的红黑树。红黑树具有良好的效率，它可在O(logN) 时间内完成查找、增加、删除等操作。
因此，红黑树在业界应用很广泛，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的
 map 均是基于红黑树结构实现的。考虑到红黑树是一种被广泛应用的数据结构，所以我们很有必
 要去弄懂它。

#### 1.1 红黑树的定义
&emsp;&emsp;红黑树通过如下的性质定义实现自平衡：

 - 1）结点是红色或者黑色。

 - 2）根是黑色。
 
 - 3）所有叶子结点都是黑色（叶子是NIL结点）
 
 - 4）每个红色结点必须有两个黑色的子结点（从每个叶子到根的所有路径上不能有两个连续的红色结点）
 
 - 5）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）
 
&emsp;&emsp;有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，
仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些
路径长度过长，那么，在对这些路径上的结点进行增删查操作时，效率也会大大降低。
这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证任意节点到其每个叶
子节点路径最长不会超过最短路径的2倍。原因如下：

&emsp;&emsp;当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径
必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了
从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，
路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。


&emsp;&emsp;因为AVL树上人和结点的左右子树的深度之差都不差过1，则可以证明他的时间复杂度为logn。

#### 1.1.2 平衡二叉树的平衡调整方法
&emsp;&emsp;如何创建一颗平衡二叉树呢？插入结点时，首先按照二叉排序树处理，若插入结点后破坏了
平衡二叉树的特性，需对平衡二叉树进行调整。调整方法是：找到里插入节点最近且平衡因子绝对值超过
1的祖先结点，以该节点为根的字数称为最小不平衡子树，可将重新平衡的范围局限于这棵子树。

&emsp;&emsp;一般情况下，假设最小不平衡子树的根结点为A，则失去平衡后进行调整的规律课归纳为下列4
种情况。

 - (1)LL型(插入发生在左子树的左结点)：右旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/ll.png)
 - (2)RR型(插入发生在右子树的右结点)：左旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/rr.png)
 - (3)LR型(插入发生在左子树的右结点)：先左旋变成LL型，再右旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/lr.png)
 - (4)RL型(插入发生在右子树的左结点)：先右旋变成RR型，再左旋
 
  ![Image text](https://github.com/hhtqaq/data-structure/raw/master/myAvlTree/img-file/rl.png)
  
#### 1.1.3 平衡二叉树的插入

   - 【算法思想】
   
     1.二叉排序树的插入
    
     2.插入后高度修改为左右最大子树高度+1
     
     3.判断左右子树高度差是否小于2，判断结点是否失衡
     
     4.当前结点node失衡：
     
     插入发生在左子树的左结点，单右旋rightRotate(node)
      
     插入发生在左子树的右结点，先左旋node.left=leftRotate(node.left) 再rightRotate(node)
    
     插入发生在右子树的右结点，单左旋leftRotate(node)
    
     插入发生在右子树的左结点，先右旋node.right=rightRotate(node.right) 再leftRotate(node)

#### 1.1.4 平衡二叉树的缺点

1 为了保证高度平衡，动态插入和删除的代价也随之增加。**红黑树**这种更加高效的查找结构可以解决这个问题。

2 在大数据量查找环境下（比如说系统磁盘里的文件目录，数据库中的记录查询 等），所有的二叉查找树结构（BST、AVL、RBT）都不合适。
如此大规模的数据量，全部组织成平衡二叉树放在内存中是不可能做到的。那么把这棵树放在磁盘中吧。
问题就来了：假如构造的平衡二叉树深度有1W层。那么从根节点出发到叶子节点很可能就需要1W次的硬盘IO读写。
所有二叉查找树结构的查找代价都与树高是紧密相关的，能否通过减少树高来进一步降低查找代价呢。我们可以通过多路查找树的结构来做到这一点。


###1.2  红黑树比AVL树的优势在哪

&emsp;&emsp;首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点
增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，
因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入删除效率更高！！！

【知乎回答：】
 - 1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树
 的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree
 最多只需3次旋转，只需要O(1)的复杂度。



    
**说明：**

&emsp;&emsp;完全二叉树，二叉查找树，平衡二叉树都是从**内存**中查找数据，相对顺序存储、链表来说
能够提升查找效率，但如果是海量数据，无法一次性读到内存中时，这些数据结构就不在适用。
此时就需要研究从**磁盘**中查找海量数据的方法，就引入了b树和b+树